
// This file is part of TRINCI.
//
// Copyright (C) 2025 Affidaty Spa.
//
// TRINCI is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// TRINCI is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
// for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with TRINCI. If not, see <https://www.gnu.org/licenses/>.

//! The `event_service` is in charge of propagating any event generated by the node to the subscribed services.
//! The available events topics are in the `EventTopics` bit-flag. A service can be subscribed and unsubscribed to a topic via
//! the `Req` enum values `Subtribe` and `Unsubscribe` respectively. In case the service wants to be detached from the `event_service`
//! it will use the `Disconnect` request.

use crate::{
    artifacts::{
        messages::{Comm, CommKind, Req, Res},
        models::{Block, NodeHash, SmartContractEvent},
    },
    Services,
};

use async_std::channel::{Receiver as AsyncReceiver, Sender as AsyncSender};
use crossbeam_channel::Sender;
use futures::future::{select, Either};
use log::{debug, info, warn};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use trinci_core_new::{artifacts::messages::send_res, log_error};

type Mask = u8;

pub struct EventService {
    pub event_receiver: AsyncReceiver<(EventTopics, Vec<u8>)>,
    pub next_connection_id: u64,
    pub node_id: String,
    pub services: Services,
    pub switchboard: HashMap<u64, (AsyncSender<Vec<u8>>, Mask)>,
}

// `bitflags` is used to represent a struct via flags
// Note: flag values respect old system configuration.
bitflags::bitflags! {
    /// Blockchain event kinds.
    #[derive(Clone, Debug, PartialEq, Eq, Hash)]
    pub struct EventTopics: u8 {
        /// New block has been created.
        const BLOCK = 1 << 1;
        /// Contracts events
        const CONTRACT_EVENTS = 1 << 3;
        /// New block has been executed.
        const BLOCK_EXEC = 1 << 5;
    }
}

// Needed for T2Lib retro-compatibility
#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(tag = "type")]
#[allow(clippy::large_enum_variant)]
pub enum Event {
    /// Get block response.
    #[serde(rename = "10")]
    BlockEvent {
        /// `Block` structure.
        block: Block,
        /// Block transactions hashes. `None` if not requested.
        txs: Option<Vec<NodeHash>>,
        /// Origin of the `Block`. `None` if local operations,
        /// and no chance to propagate outside the response.
        origin: Option<String>,
    },
    /// Get the contracts events.
    #[serde(rename = "15")] // Number picked on T2 implementation.
    ContractEvent {
        /// `Event` structure.
        event: SmartContractEvent,
    },
}

impl EventService {
    pub async fn start(
        event_receiver: AsyncReceiver<(EventTopics, Vec<u8>)>,
        event_service_receiver: AsyncReceiver<Comm>,
        node_id: String,
        services: Services,
    ) {
        let service = Self {
            event_receiver,
            next_connection_id: 0,
            node_id,
            services,
            switchboard: HashMap::new(),
        };

        info!("EventService successfully started.");
        service.run(event_service_receiver).await;
    }

    async fn run(mut self, event_service_receiver: AsyncReceiver<Comm>) {
        loop {
            match select(self.event_receiver.recv(), event_service_receiver.recv()).await {
                Either::Left((event, _)) => {
                    if let Ok(event) = event {
                        self.propagate_event(event).await;
                    }
                }
                Either::Right((int_comm, _)) => {
                    if let Ok(int_comm) = int_comm {
                        match int_comm.kind.clone() {
                            CommKind::Msg(msg) => {
                                log_error!(format!(
                                    "Node {}, EventService: received unexpected Msg ({msg:?})",
                                    self.node_id,
                                ));
                                return;
                            }
                            CommKind::Req(req) => {
                                self.handle_requests(
                                    req,
                                    "EventService",
                                    &int_comm
                                        .res_chan
                                        .expect("Here I should always have a channel"),
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[inline]
    fn handle_requests(&mut self, req: Req, from_service: &str, res_chan: &Sender<Res>) {
        match req {
            Req::Subscribe {
                event_topics,
                event_sender,
                subscriber_id,
            } => {
                debug!(
                    "Node {} received `Subscribe` req from {subscriber_id:?} to topics {event_topics:?}",
                    self.node_id,
                );

                // Collects topics in bit-flags form.
                let topics = event_topics.bits();

                // In case id is declared in the request use that one
                // otherwise use the incremental one.
                let response = if let Some(id) = subscriber_id {
                    // If the id is present in the switchboard,
                    // updates its masks and returns the notification channel,
                    // id and the required mask for the topics for which the sender
                    // requested a subscription.
                    // Otherwise if the id is not present return `None`
                    if let Some((_, listener_mask)) = self.switchboard.get_mut(&id) {
                        *listener_mask |= topics;
                        Some(id)
                    } else {
                        warn!("Node {}, EventService: received unexpected id ({id}) from service {from_service} during Subscribe", self.node_id);
                        None
                    }
                } else {
                    // Adds a new event listener, save its id and is mask.
                    // Returns its id, event channel and requested mask.
                    let id = self.next_connection_id;
                    let _ = self.switchboard.insert(id, (event_sender, topics));
                    self.next_connection_id += 1;
                    Some(id)
                };

                send_res(
                    &self.node_id,
                    "EventService",
                    from_service,
                    res_chan,
                    Res::Subscribe(response),
                );
            }
            Req::Unsubscribe {
                event_topics,
                subscriber_id,
            } => {
                debug!(
                    "Node {} received `Unsubscribe` req from {subscriber_id:?} from topics {event_topics:?}",
                    self.node_id,
                );

                // Collects topics in bit-flags form.
                let topics = event_topics.bits();

                // Collects given id switchboard ad updates it and return the new value.
                // In case id is not present in switchboard return `None`.
                let response = if let Some((_, listener_mask)) =
                    self.switchboard.get_mut(&subscriber_id)
                {
                    *listener_mask ^= topics;

                    // In case the sender is subscribed to any topics,
                    // it can be removed from the switchboard.
                    if *listener_mask == 0 {
                        self.switchboard.remove(&subscriber_id);
                    }
                    true
                } else {
                    warn!("Node {}, EventService: received unexpected id ({subscriber_id}) from service {from_service} during Unsubscribe", self.node_id);
                    false
                };

                send_res(
                    &self.node_id,
                    "EventService",
                    from_service,
                    res_chan,
                    Res::Unsubscribe(response),
                );
            }
            Req::Disconnect(subscriber_id) => {
                // In case subscriber is present, removes it and returns `true`.
                let res = self.switchboard.remove(&subscriber_id).is_some();

                send_res(
                    &self.node_id,
                    "EventService",
                    from_service,
                    res_chan,
                    Res::Disconnect(res),
                );
            }
            _ => {
                log_error!(format!(
                    "Node {}, EventService: received unexpected Req ({req:?})",
                    self.node_id,
                ));
            }
        }
    }

    #[inline]
    async fn propagate_event(&self, event: (EventTopics, Vec<u8>)) {
        debug!("Node {} received event {:?}", self.node_id, event.0);

        for (sender, mask) in self.switchboard.values() {
            if (mask & event.0.bits()) > 0 {
                let _res = sender.send(event.1.clone()).await;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        artifacts::messages::{send_req_async, Comm, CommKind, Req, Res},
        services::event_service::{EventService, EventTopics},
        Services,
    };

    use async_std::channel::{
        unbounded as async_unbounded, Receiver as AsyncReceiver, Sender as AsyncSender,
    };
    use crossbeam_channel::{unbounded, Receiver, Sender};

    fn mock_services() -> Services {
        let comms_db_service: (Sender<Comm>, Receiver<Comm>) = unbounded();
        let comms_event_service: (AsyncSender<Comm>, AsyncReceiver<Comm>) = async_unbounded();
        let comms_p2p_service: (AsyncSender<Comm>, AsyncReceiver<Comm>) = async_unbounded();
        let comms_wasm_service: (Sender<Comm>, Receiver<Comm>) = unbounded();

        Services {
            db_service: comms_db_service.0,
            event_service: comms_event_service.0,
            p2p_service: comms_p2p_service.0,
            wasm_service: comms_wasm_service.0,
        }
    }

    fn start_event_service(event_service_receiver: AsyncReceiver<Comm>) {
        async_std::task::spawn(async move {
            EventService::start(
                async_unbounded().1,
                event_service_receiver,
                "test".to_string(),
                mock_services(),
            )
            .await
        });
    }

    #[test]
    fn events_subscribe() {
        let comms_event_service: (AsyncSender<Comm>, AsyncReceiver<Comm>) = async_unbounded();
        start_event_service(comms_event_service.1);

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let async_chan: (AsyncSender<Vec<u8>>, AsyncReceiver<Vec<u8>>) = async_unbounded();
        let Ok(Res::Subscribe(Some(id))) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::CONTRACT_EVENTS,
                    event_sender: async_chan.0,
                    subscriber_id: None,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        let mut mask = 0_u8;
        mask |= EventTopics::CONTRACT_EVENTS.bits();

        assert_eq!(id, 0);
        assert_eq!(mask, 8);

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let async_chan: (AsyncSender<Vec<u8>>, AsyncReceiver<Vec<u8>>) = async_unbounded();
        let Ok(Res::Subscribe(Some(id))) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::BLOCK,
                    event_sender: async_chan.0,
                    subscriber_id: Some(id),
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        mask |= EventTopics::BLOCK.bits();

        assert_eq!(id, 0);
        assert_eq!(mask, 10);

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let async_chan: (AsyncSender<Vec<u8>>, AsyncReceiver<Vec<u8>>) = async_unbounded();
        let Ok(Res::Subscribe(Some(id))) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::BLOCK_EXEC,
                    event_sender: async_chan.0,
                    subscriber_id: None,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        mask |= EventTopics::BLOCK_EXEC.bits();

        assert_eq!(id, 1);
        assert_eq!(mask, 42);
    }

    #[test]
    fn events_subscribe_multiple() {
        let comms_event_service: (AsyncSender<Comm>, AsyncReceiver<Comm>) = async_unbounded();
        start_event_service(comms_event_service.1);

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let async_chan: (AsyncSender<Vec<u8>>, AsyncReceiver<Vec<u8>>) = async_unbounded();
        let Ok(Res::Subscribe(Some(id))) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::CONTRACT_EVENTS | EventTopics::BLOCK_EXEC,
                    event_sender: async_chan.0,
                    subscriber_id: None,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        let mut mask = 0_u8;
        mask |= (EventTopics::CONTRACT_EVENTS | EventTopics::BLOCK_EXEC).bits();

        assert_eq!(id, 0);
        assert_eq!(mask, 40);
    }

    #[test]
    fn events_unsubscribe() {
        let comms_event_service: (AsyncSender<Comm>, AsyncReceiver<Comm>) = async_unbounded();
        start_event_service(comms_event_service.1);

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let async_chan: (AsyncSender<Vec<u8>>, AsyncReceiver<Vec<u8>>) = async_unbounded();
        let Ok(Res::Subscribe(Some(id))) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::CONTRACT_EVENTS | EventTopics::BLOCK_EXEC,
                    event_sender: async_chan.0,
                    subscriber_id: None,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        let mut mask = 0_u8;
        mask |= (EventTopics::CONTRACT_EVENTS | EventTopics::BLOCK_EXEC).bits();

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let Ok(Res::Unsubscribe(true)) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Unsubscribe {
                    event_topics: EventTopics::BLOCK_EXEC,
                    subscriber_id: 0,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        mask ^= EventTopics::BLOCK_EXEC.bits();

        assert_eq!(id, 0);
        assert_eq!(mask, 8);
    }

    #[test]
    fn events_subscribe_error() {
        let comms_event_service: (AsyncSender<Comm>, AsyncReceiver<Comm>) = async_unbounded();
        start_event_service(comms_event_service.1);

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let async_chan: (AsyncSender<Vec<u8>>, AsyncReceiver<Vec<u8>>) = async_unbounded();
        let Ok(Res::Subscribe(response)) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::CONTRACT_EVENTS | EventTopics::BLOCK_EXEC,
                    event_sender: async_chan.0,
                    subscriber_id: Some(42),
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        assert!(response.is_none());
    }

    #[test]
    fn events_unsubscribe_error() {
        let comms_event_service: (AsyncSender<Comm>, AsyncReceiver<Comm>) = async_unbounded();
        start_event_service(comms_event_service.1);

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let async_chan: (AsyncSender<Vec<u8>>, AsyncReceiver<Vec<u8>>) = async_unbounded();
        let Ok(Res::Subscribe(Some(id))) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::CONTRACT_EVENTS | EventTopics::BLOCK_EXEC,
                    event_sender: async_chan.0,
                    subscriber_id: None,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        let mut mask = 0_u8;
        mask |= (EventTopics::CONTRACT_EVENTS | EventTopics::BLOCK_EXEC).bits();

        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let Ok(Res::Unsubscribe(response)) = send_req_async(
            "test",
            "test",
            "EventService",
            &comms_event_service.0,
            Comm::new(
                CommKind::Req(Req::Unsubscribe {
                    event_topics: EventTopics::BLOCK_EXEC,
                    subscriber_id: 42,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) else {
            panic!();
        };

        assert_eq!(id, 0);
        assert_eq!(mask, 40);
        assert!(!response);
    }
}
