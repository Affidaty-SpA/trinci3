
// This file is part of TRINCI.
//
// Copyright (C) 2025 Affidaty Spa.
//
// TRINCI is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// TRINCI is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
// for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with TRINCI. If not, see <https://www.gnu.org/licenses/>.

//! The `kafka_service` is used to send any event generated by the `event_service` to a Kafka server. The connection info are collected from the `start` method.

use async_std::channel::unbounded as async_unbounded;
use crossbeam_channel::{unbounded, Receiver, Sender};
use futures::future::{select, Either};
use kafka::producer::{Producer, Record, RequiredAcks};
use log::info;
use std::time::Duration;
use trinci_core_new::log_error;

use crate::artifacts::errors::CommError;
use crate::artifacts::messages::{send_req_async, Comm, CommKind, Req, Res};
use crate::Services;

use super::event_service::EventTopics;

/// Bridge service configuration.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Config {
    /// Listening IP address (e.g. "127.0.0.1" for localhost)
    pub addr: String,
    /// Listening TCP port.
    pub port: u16,
}

const SMARTCONTRACT_EVENT: &str = "trinci_messages_transaction_event";
const BLOCK_EVENT: &str = "trinci_messages_get_block_response";

pub struct KafkaService {
    pub node_id: String,
    pub services: Services,
    pub producer: Producer,
}

impl KafkaService {
    fn send_to_kafka(&mut self, topic: &str, payload: Vec<u8>) {
        let hex = hex::encode(payload);

        match self.producer.send(&Record::from_value(topic, hex)) {
            Ok(_) => (),
            Err(e) => {
                log_error!(format!(
                    "Kafka producer is unable to send messages to the server, reason: {e}"
                ));
            }
        }
    }

    pub fn start(node_id: String, config: Config, services: Services) {
        let host = &format!("{}:{}", config.addr, config.port);

        let producer = Producer::from_hosts(vec![host.to_owned()])
            .with_ack_timeout(Duration::from_secs(1))
            .with_required_acks(RequiredAcks::One)
            .create()
            .map_err(|e| {
                log_error!(format!(
                    "Error during kafka producer initialization, reason: {}",
                    e
                ))
            })
            .unwrap();

        let mut service = Self {
            node_id,
            services,
            producer,
        };

        info!("Kafka service successfully started.");
        async_std::task::spawn(async move {
            service.run().await;
        });
    }

    async fn run(&mut self) {
        // Creates a `BLOCK_EXEC` event subscription
        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let (block_exec_event_sender, block_exec_event_receiver) = async_unbounded();
        let _connection_id_block_events = match send_req_async(
            &self.node_id,
            "KafkaService",
            "EventService",
            &self.services.event_service,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::BLOCK_EXEC,
                    event_sender: block_exec_event_sender,
                    subscriber_id: None,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) {
            Ok(Res::Subscribe(Some(connection_id))) => connection_id,
            Ok(_) => {
                log_error!(CommError::InvalidComm::<Comm>);
                panic!("Kafka scrive was unable to subscribe to `BLOCK_EXEC` topic, reason: Unexpected response from `EventService`");
            }
            Err(e) => {
                log_error!(format!("{e}"));
                panic!("Kafka scrive was unable to subscribe to `BLOCK_EXEC` topic, reason: {e}");
            }
        };

        // Creates a `CONTRACTS_EVENTS` event subscription
        let chan: (Sender<Res>, Receiver<Res>) = unbounded();
        let (contracts_events_sender, contracts_events_receiver) = async_unbounded();
        let _connection_id_contracts_events = match send_req_async(
            &self.node_id,
            "KafkaService",
            "EventService",
            &self.services.event_service,
            Comm::new(
                CommKind::Req(Req::Subscribe {
                    event_topics: EventTopics::CONTRACT_EVENTS,
                    event_sender: contracts_events_sender,
                    subscriber_id: None,
                }),
                Some(chan.0),
            ),
            &chan.1,
        ) {
            Ok(Res::Subscribe(Some(connection_id))) => connection_id,
            Ok(_) => {
                log_error!(CommError::InvalidComm::<Comm>);
                panic!("Kafka service was unable to subscribe to `CONTRACTS_EVENTS` topic, reason: Unexpected response from `EventService`");
            }
            Err(e) => {
                log_error!(format!("{e}"));
                panic!(
                    "Kafka service was unable to subscribe to `CONTRACTS_EVENTS` topic, reason: {e}"
                );
            }
        };

        loop {
            match select(
                block_exec_event_receiver.recv(),
                contracts_events_receiver.recv(),
            )
            .await
            {
                Either::Left((Ok(block_buf), _)) => {
                    self.send_to_kafka(BLOCK_EVENT, block_buf);
                }
                Either::Right((Ok(contract_buf), _)) => {
                    self.send_to_kafka(SMARTCONTRACT_EVENT, contract_buf);
                }
                _ => {}
            }
        }
    }
}
